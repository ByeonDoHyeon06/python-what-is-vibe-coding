 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF'
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000000000000000000000000000000000000..25ff10abe221d26a0547e83cc5a29e4b5f2b2117
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,6 @@
+__pycache__/
+*.pyc
+*.pyo
+*.pyd
+*.db
+data/
diff --git a/README.md b/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..a09fd861a95e3ce086ee201009af9188a54d45ce
--- /dev/null
+++ b/README.md
@@ -0,0 +1,178 @@
+# VibeCoding Hosting Backend (FastAPI)
+
+## Getting started
+1. Install dependencies
+   ```bash
+   pip install -r requirements.txt
+   ```
+2. Run the API
+   ```bash
+   uvicorn app.main:app --reload
+   ```
+3. Visit the docs at [`/docs`](http://localhost:8000/docs) for interactive testing.
+
+## Available endpoints (happy-path flow)
+- `POST /admin/plans` – admin creates/updates plan presets (vcpu, memory, disk, location, proxmox host/node mapping, optional template clone info).
+- `GET /admin/plans` – list all configured plans.
+- `POST /admin/proxmox/hosts` – admin registers a Proxmox API endpoint (api_url, username/password/realm, node, location tag).
+- `GET /admin/proxmox/hosts` – list configured Proxmox endpoints.
+- `POST /users` – register a customer with `email`, `phone_number`, and optional `external_auth_id` (to link your auth provider).
+- `GET /users` – list registered customers.
+- `GET /servers/metadata/allowed` – discover configured plan specs and available locations before provisioning.
+- `POST /servers` – provision a server for a user. Body example:
+  ```json
+  {
+    "user_id": "<user uuid from /users>",
+    "plan": "basic",
+    "location": "kr-central"
+  }
+  ```
+- `GET /servers/user/{user_id}` – list servers created for a specific user.
+- `GET /servers/{server_id}` – fetch a single server.
+- `GET /healthz` – simple health check.
+
+## How the Proxmox & SOLAPI adapters work
+- `app/infrastructure/clients/proxmox.py` – logs in with username/password (realm defaults to `pam`) to fetch a ticket/CSRF token, then hits the Proxmox API to create VMs on the configured node. It supports cloning from a template VMID defined on the plan (with optional storage target) or creating a fresh VM. The host/node credentials come from the admin-managed catalog (or the fallback `PROXMOX_*` env values if provided).
+- `app/infrastructure/clients/solapi.py` – place to call the official SOLAPI SDK. It reads `SOLAPI_KEY`, `SOLAPI_SECRET`, and `SOLAPI_FROM`. Implement SMS sending in `send_provisioning_sms`.
+
+Both clients are injected into the saga orchestrator (`app/application/services/server_orchestrator.py`), which sets the server status, calls Proxmox, and sends an SMS. If an exception occurs, the orchestrator rolls back by calling `destroy_server` and marking the server as `ROLLED_BACK`.
+
+## Configuration
+- Defaults live in `app/infrastructure/config/settings.py` and are overrideable via environment variables or a local `.env` file.
+- Proxmox defaults (used only if no admin hosts are registered):
+  - `PROXMOX_HOST` (e.g., `https://proxmox.local`)
+  - `PROXMOX_USERNAME`
+  - `PROXMOX_PASSWORD`
+  - `PROXMOX_REALM` (defaults to `pam`)
+- Persistence: set `DATABASE_PATH` to control where the SQLite file is written (defaults to `data/vibecoding.db`).
+- Provisioning policy uses the admin-managed plan catalog and Proxmox host catalog; the metadata endpoint exposes what is currently configured.
+
+## Example cURL
+Bootstrap one host/plan via admin APIs (optional if you rely on `.env` defaults):
+```bash
+# Register a Proxmox endpoint with username/password auth
+curl -X POST http://localhost:8000/admin/proxmox/hosts \
+  -H "Content-Type: application/json" \
+  -d '{"id":"pve1","api_url":"https://proxmox.local","username":"root","password":"changeme","realm":"pam","node":"pve","location":"kr-central"}'
+
+# Register a plan bound to that host
+curl -X POST http://localhost:8000/admin/plans \
+  -H "Content-Type: application/json" \
+  -d '{"name":"basic","vcpu":1,"memory_mb":1024,"disk_gb":20,"location":"kr-central","proxmox_host_id":"pve1","proxmox_node":"pve"}'
+```
+
+```bash
+# 1) Register a user
+curl -X POST http://localhost:8000/users \
+  -H "Content-Type: application/json" \
+  -d '{"email":"test@example.com","phone_number":"01012345678"}'
+
+# 2) Check allowed plans/locations
+curl http://localhost:8000/servers/metadata/allowed
+
+# 3) Provision a server
+curl -X POST http://localhost:8000/servers \
+  -H "Content-Type: application/json" \
+  -d '{"user_id":"<uuid>","plan":"basic","location":"kr-central"}'
+```
+
+## End-to-end walkthrough (expected responses)
+Assuming the app is running locally on port `8000`:
+
+```bash
+# 1) Register a user
+curl -s -X POST http://localhost:8000/users \
+  -H "Content-Type: application/json" \
+  -d '{"email":"demo@example.com","phone_number":"01099998888"}' | jq
+```
+Expected response:
+```json
+{
+  "id": "0e9a8db2-4c03-4c5d-9a22-5601d2e4d4f1",
+  "email": "demo@example.com",
+  "phone_number": "01099998888",
+  "external_auth_id": null
+}
+```
+
+```bash
+# 2) See allowed plans/locations before provisioning
+curl -s http://localhost:8000/servers/metadata/allowed | jq
+```
+Expected response:
+```json
+{
+  "plans": [
+    {
+      "name": "basic",
+      "location": "kr-central",
+      "vcpu": 1,
+      "memory_mb": 1024,
+      "disk_gb": 20,
+      "proxmox_host_id": "default",
+      "proxmox_node": null,
+      "description": "Default starter plan"
+    }
+  ],
+  "locations": ["kr-central"]
+}
+```
+
+```bash
+# 3) Provision a server for the user
+curl -s -X POST http://localhost:8000/servers \
+  -H "Content-Type: application/json" \
+  -d '{"user_id":"0e9a8db2-4c03-4c5d-9a22-5601d2e4d4f1","plan":"basic","location":"kr-central"}' | jq
+```
+Expected response (IDs will differ):
+```json
+{
+  "id": "8c04a4df-1fae-4b43-8d45-b69d49fe4f57",
+  "owner_id": "0e9a8db2-4c03-4c5d-9a22-5601d2e4d4f1",
+  "plan": "basic",
+  "location": "kr-central",
+  "proxmox_host_id": "default",
+  "proxmox_node": null,
+  "vcpu": 1,
+  "memory_mb": 1024,
+  "disk_gb": 20,
+  "status": "active",
+  "external_id": "vm-8c04a4df-1fae-4b43-8d45-b69d49fe4f57"
+}
+```
+
+```bash
+# 4) Fetch the server directly (or list all servers for the user)
+curl -s http://localhost:8000/servers/8c04a4df-1fae-4b43-8d45-b69d49fe4f57 | jq
+curl -s http://localhost:8000/servers/user/0e9a8db2-4c03-4c5d-9a22-5601d2e4d4f1 | jq
+```
+Each server will show its persisted state:
+```json
+[
+  {
+    "id": "8c04a4df-1fae-4b43-8d45-b69d49fe4f57",
+    "owner_id": "0e9a8db2-4c03-4c5d-9a22-5601d2e4d4f1",
+    "plan": "basic",
+    "location": "kr-central",
+    "proxmox_host_id": "default",
+    "proxmox_node": null,
+    "vcpu": 1,
+    "memory_mb": 1024,
+    "disk_gb": 20,
+    "status": "active",
+    "external_id": "vm-8c04a4df-1fae-4b43-8d45-b69d49fe4f57"
+  }
+]
+```
+
+```bash
+# 5) Confirm the health endpoint if needed
+curl -s http://localhost:8000/healthz
+```
+```json
+{"status":"ok"}
+```
+
+## Notes
+- Persistence now uses SQLite via lightweight repositories; set `DATABASE_PATH` to move the DB file.
+- Validation/rollback is handled in the `ProvisionServer` use case and the `ServerProvisionOrchestrator`.
diff --git a/app/__init__.py b/app/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/app/api/__init__.py b/app/api/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/app/api/dependencies/__init__.py b/app/api/dependencies/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..68ae89816afc47333472a07d4d0bc7fd1f79ba75
--- /dev/null
+++ b/app/api/dependencies/__init__.py
@@ -0,0 +1,120 @@
+from functools import lru_cache
+
+from app.application.services.server_orchestrator import ServerProvisionOrchestrator
+from app.application.use_cases.provision_server import ProvisionServer
+from app.application.use_cases.register_user import RegisterUser
+from app.domain.models.plan import PlanSpec
+from app.domain.models.proxmox_host import ProxmoxHostConfig
+from app.domain.services.provisioning_policy import ProvisioningPolicy
+from app.infrastructure.clients.proxmox import ProxmoxClient
+from app.infrastructure.clients.solapi import SolapiClient
+from app.infrastructure.config.settings import settings
+from app.infrastructure.repositories.plan_repository import PlanRepository
+from app.infrastructure.repositories.proxmox_host_repository import ProxmoxHostRepository
+from app.infrastructure.repositories.server_repository import ServerRepository
+from app.infrastructure.repositories.user_repository import UserRepository
+from app.infrastructure.storage.sqlite import SQLiteDataStore
+
+
+@lru_cache()
+def get_datastore() -> SQLiteDataStore:
+    return SQLiteDataStore(settings.database_path)
+
+
+@lru_cache()
+def get_user_repository() -> UserRepository:
+    return UserRepository(get_datastore())
+
+
+@lru_cache()
+def get_server_repository() -> ServerRepository:
+    return ServerRepository(get_datastore())
+
+
+@lru_cache()
+def get_plan_repository() -> PlanRepository:
+    repo = PlanRepository(get_datastore())
+    if not repo.get("basic"):
+        repo.add(
+            PlanSpec(
+                name="basic",
+                vcpu=1,
+                memory_mb=1024,
+                disk_gb=20,
+                location="kr-central",
+                description="Default starter plan",
+                disk_storage="local-lvm",
+            )
+        )
+    if not repo.get("pro"):
+        repo.add(
+            PlanSpec(
+                name="pro",
+                vcpu=2,
+                memory_mb=4096,
+                disk_gb=80,
+                location="kr-central",
+                description="Larger VM for heavier workloads",
+                disk_storage="local-lvm",
+            )
+        )
+    return repo
+
+
+@lru_cache()
+def get_proxmox_host_repository() -> ProxmoxHostRepository:
+    repo = ProxmoxHostRepository(get_datastore())
+    if settings.proxmox_password:
+        repo.add(
+            ProxmoxHostConfig(
+                id="default",
+                api_url=settings.proxmox_host,
+                username=settings.proxmox_username,
+                password=settings.proxmox_password,
+                realm=settings.proxmox_realm,
+                node=None,
+                location="kr-central",
+            )
+        )
+    return repo
+
+
+@lru_cache()
+def get_provisioning_policy() -> ProvisioningPolicy:
+    return ProvisioningPolicy(plans=get_plan_repository(), proxmox_hosts=get_proxmox_host_repository())
+
+
+@lru_cache()
+def get_proxmox_client() -> ProxmoxClient:
+    return ProxmoxClient()
+
+
+@lru_cache()
+def get_solapi_client() -> SolapiClient:
+    return SolapiClient()
+
+
+@lru_cache()
+def get_server_orchestrator() -> ServerProvisionOrchestrator:
+    return ServerProvisionOrchestrator(
+        server_repo=get_server_repository(),
+        proxmox_hosts=get_proxmox_host_repository(),
+        proxmox_client=get_proxmox_client(),
+        solapi_client=get_solapi_client(),
+    )
+
+
+@lru_cache()
+def get_user_registration() -> RegisterUser:
+    return RegisterUser(repository=get_user_repository())
+
+
+@lru_cache()
+def get_server_provisioning() -> ProvisionServer:
+    return ProvisionServer(
+        server_repo=get_server_repository(),
+        user_repo=get_user_repository(),
+        proxmox_hosts=get_proxmox_host_repository(),
+        policy=get_provisioning_policy(),
+        orchestrator=get_server_orchestrator(),
+    )
diff --git a/app/api/routes/admin.py b/app/api/routes/admin.py
new file mode 100644
index 0000000000000000000000000000000000000000..68cfd35d86f532beb1e2ad38c38100e1ecd56134
--- /dev/null
+++ b/app/api/routes/admin.py
@@ -0,0 +1,39 @@
+from fastapi import APIRouter, Depends
+
+from app.api.dependencies import get_plan_repository, get_proxmox_host_repository
+from app.domain.models.plan import PlanSpec
+from app.domain.models.proxmox_host import ProxmoxHostConfig
+from app.infrastructure.repositories.plan_repository import PlanRepository
+from app.infrastructure.repositories.proxmox_host_repository import ProxmoxHostRepository
+from app.interfaces.schemas import (
+    PlanCreate,
+    PlanRead,
+    ProxmoxHostCreate,
+    ProxmoxHostRead,
+)
+
+router = APIRouter(prefix="/admin", tags=["admin"])
+
+
+@router.post("/plans", response_model=PlanRead)
+def create_plan(payload: PlanCreate, repo: PlanRepository = Depends(get_plan_repository)):
+    plan = PlanSpec(**payload.dict())
+    repo.add(plan)
+    return PlanRead.from_entity(plan)
+
+
+@router.get("/plans", response_model=list[PlanRead])
+def list_plans(repo: PlanRepository = Depends(get_plan_repository)):
+    return [PlanRead.from_entity(plan) for plan in repo.list()]
+
+
+@router.post("/proxmox/hosts", response_model=ProxmoxHostRead)
+def add_proxmox_host(payload: ProxmoxHostCreate, repo: ProxmoxHostRepository = Depends(get_proxmox_host_repository)):
+    host = ProxmoxHostConfig(**payload.dict())
+    repo.add(host)
+    return ProxmoxHostRead.from_entity(host)
+
+
+@router.get("/proxmox/hosts", response_model=list[ProxmoxHostRead])
+def list_proxmox_hosts(repo: ProxmoxHostRepository = Depends(get_proxmox_host_repository)):
+    return [ProxmoxHostRead.from_entity(host) for host in repo.list()]
diff --git a/app/api/routes/servers.py b/app/api/routes/servers.py
new file mode 100644
index 0000000000000000000000000000000000000000..bd1462b4014cbc4dd718dcb1c1731c8009363e59
--- /dev/null
+++ b/app/api/routes/servers.py
@@ -0,0 +1,69 @@
+from uuid import UUID
+
+from fastapi import APIRouter, Depends, HTTPException
+
+from app.api.dependencies import (
+    get_plan_repository,
+    get_proxmox_host_repository,
+    get_server_provisioning,
+    get_server_repository,
+)
+from app.infrastructure.repositories.plan_repository import PlanRepository
+from app.infrastructure.repositories.proxmox_host_repository import ProxmoxHostRepository
+from app.infrastructure.repositories.server_repository import ServerRepository
+from app.interfaces.schemas import ServerCreate, ServerRead
+
+router = APIRouter(prefix="/servers", tags=["servers"])
+
+
+@router.post("", response_model=ServerRead)
+def provision_server(
+    payload: ServerCreate,
+    provision = Depends(get_server_provisioning),
+):
+    try:
+        server = provision.execute(user_id=payload.user_id, plan=payload.plan, location=payload.location)
+        return ServerRead.from_entity(server)
+    except ValueError as exc:
+        raise HTTPException(status_code=400, detail=str(exc)) from exc
+
+
+@router.get("/user/{user_id}", response_model=list[ServerRead])
+def list_user_servers(user_id: UUID, repo: ServerRepository = Depends(get_server_repository)):
+    servers = repo.list_for_user(user_id=user_id)
+    return [ServerRead.from_entity(server) for server in servers]
+
+
+@router.get("/metadata/allowed", tags=["metadata"])
+def get_allowed_plans_and_locations(
+    plans: PlanRepository = Depends(get_plan_repository),
+    hosts: ProxmoxHostRepository = Depends(get_proxmox_host_repository),
+):
+    """Expose discoverable provisioning metadata (plans + Proxmox locations)."""
+
+    return {
+        "plans": [
+            {
+                "name": plan.name,
+                "location": plan.location,
+                "vcpu": plan.vcpu,
+                "memory_mb": plan.memory_mb,
+                "disk_gb": plan.disk_gb,
+                "proxmox_host_id": plan.proxmox_host_id,
+                "proxmox_node": plan.proxmox_node,
+                "template_vmid": plan.template_vmid,
+                "disk_storage": plan.disk_storage,
+                "description": plan.description,
+            }
+            for plan in plans.list()
+        ],
+        "locations": sorted({host.location for host in hosts.list()}),
+    }
+
+
+@router.get("/{server_id}", response_model=ServerRead)
+def get_server(server_id: UUID, repo: ServerRepository = Depends(get_server_repository)):
+    server = repo.get(server_id)
+    if not server:
+        raise HTTPException(status_code=404, detail="Server not found")
+    return ServerRead.from_entity(server)
diff --git a/app/api/routes/users.py b/app/api/routes/users.py
new file mode 100644
index 0000000000000000000000000000000000000000..4f0e94fd7d822bbb3c3481c16a8756b0c5c05ea6
--- /dev/null
+++ b/app/api/routes/users.py
@@ -0,0 +1,25 @@
+from fastapi import APIRouter, Depends
+
+from app.api.dependencies import get_user_registration, get_user_repository
+from app.infrastructure.repositories.user_repository import UserRepository
+from app.interfaces.schemas import UserCreate, UserRead
+
+router = APIRouter(prefix="/users", tags=["users"])
+
+
+@router.post("", response_model=UserRead)
+def register_user(
+    payload: UserCreate,
+    register = Depends(get_user_registration),
+):
+    user = register.execute(
+        email=payload.email,
+        phone_number=payload.phone_number,
+        external_auth_id=payload.external_auth_id,
+    )
+    return UserRead.from_entity(user)
+
+
+@router.get("", response_model=list[UserRead])
+def list_users(user_repo: UserRepository = Depends(get_user_repository)):
+    return [UserRead.from_entity(user) for user in user_repo.list()]
diff --git a/app/application/__init__.py b/app/application/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/app/application/services/server_orchestrator.py b/app/application/services/server_orchestrator.py
new file mode 100644
index 0000000000000000000000000000000000000000..403c242227ff05b10ae064325fd5fb34d1f8a085
--- /dev/null
+++ b/app/application/services/server_orchestrator.py
@@ -0,0 +1,61 @@
+from app.domain.models.plan import PlanSpec
+from app.domain.models.proxmox_host import ProxmoxHostConfig
+from app.domain.models.server import Server, ServerStatus
+from app.domain.models.user import User
+from app.infrastructure.clients.proxmox import ProxmoxClient
+from app.infrastructure.clients.solapi import SolapiClient
+from app.infrastructure.repositories.proxmox_host_repository import ProxmoxHostRepository
+from app.infrastructure.repositories.server_repository import ServerRepository
+
+
+class ServerProvisionOrchestrator:
+    """Implements a saga-style orchestration around server provisioning.
+
+    * Validates the domain rules (done upstream).
+    * Calls Proxmox to create infrastructure.
+    * Sends SMS notifications via SOLAPI.
+    * Rolls back the Proxmox resource when any step fails.
+    """
+
+    def __init__(
+        self,
+        server_repo: ServerRepository,
+        proxmox_hosts: ProxmoxHostRepository,
+        proxmox_client: ProxmoxClient,
+        solapi_client: SolapiClient,
+    ):
+        self.server_repo = server_repo
+        self.proxmox_hosts = proxmox_hosts
+        self.proxmox_client = proxmox_client
+        self.solapi_client = solapi_client
+
+    def provision(self, server: Server, user: User, plan: PlanSpec, host: ProxmoxHostConfig) -> None:
+        try:
+            server.status = ServerStatus.PROVISIONING
+            self.server_repo.update(server)
+
+            external_id = self.proxmox_client.provision_server(server, plan=plan, host=host)
+            server.external_id = external_id
+
+            server.status = ServerStatus.ACTIVE
+            self.server_repo.update(server)
+
+            self.solapi_client.send_provisioning_sms(
+                to=user.phone_number,
+                message=(
+                    f"{user.email}님, 서버가 준비되었습니다. "
+                    f"ID: {server.external_id}, 플랜: {server.plan}, 위치: {server.location}"
+                ),
+            )
+        except Exception as exc:  # noqa: BLE001
+            self._rollback(server)
+            raise exc
+
+    def _rollback(self, server: Server) -> None:
+        if server.external_id and server.proxmox_host_id:
+            host = self.proxmox_hosts.get(server.proxmox_host_id)
+            if host:
+                node = server.proxmox_node or host.node
+                self.proxmox_client.destroy_server(server.external_id, host=host, node=node)
+        server.status = ServerStatus.ROLLED_BACK
+        self.server_repo.update(server)
diff --git a/app/application/use_cases/provision_server.py b/app/application/use_cases/provision_server.py
new file mode 100644
index 0000000000000000000000000000000000000000..0169d5516b463c5572644450535e8405dd371e89
--- /dev/null
+++ b/app/application/use_cases/provision_server.py
@@ -0,0 +1,49 @@
+from uuid import UUID
+
+from app.domain.models.server import Server
+from app.domain.services.provisioning_policy import ProvisioningPolicy
+from app.infrastructure.repositories.plan_repository import PlanRepository
+from app.infrastructure.repositories.proxmox_host_repository import ProxmoxHostRepository
+from app.infrastructure.repositories.server_repository import ServerRepository
+from app.infrastructure.repositories.user_repository import UserRepository
+from app.application.services.server_orchestrator import ServerProvisionOrchestrator
+
+
+class ProvisionServer:
+    """Entry point to kick off provisioning for a user purchase."""
+
+    def __init__(
+        self,
+        server_repo: ServerRepository,
+        user_repo: UserRepository,
+        proxmox_hosts: ProxmoxHostRepository,
+        policy: ProvisioningPolicy,
+        orchestrator: ServerProvisionOrchestrator,
+    ):
+        self.server_repo = server_repo
+        self.user_repo = user_repo
+        self.proxmox_hosts = proxmox_hosts
+        self.policy = policy
+        self.orchestrator = orchestrator
+
+    def execute(self, user_id: UUID, plan: str, location: str) -> Server:
+        user = self.user_repo.get(user_id)
+        if not user:
+            raise ValueError("User not found")
+
+        plan_spec = self.policy.resolve_plan(plan)
+        host = self.policy.resolve_host(location, plan_spec)
+
+        server = Server(
+            owner_id=user_id,
+            plan=plan_spec.name,
+            location=location,
+            proxmox_host_id=plan_spec.proxmox_host_id or host.id,
+            proxmox_node=plan_spec.proxmox_node or host.node,
+            vcpu=plan_spec.vcpu,
+            memory_mb=plan_spec.memory_mb,
+            disk_gb=plan_spec.disk_gb,
+        )
+        self.server_repo.add(server)
+        self.orchestrator.provision(server, user, plan_spec, host)
+        return server
diff --git a/app/application/use_cases/register_user.py b/app/application/use_cases/register_user.py
new file mode 100644
index 0000000000000000000000000000000000000000..bf89a8899de8bf183281e01d20f936d9893cb509
--- /dev/null
+++ b/app/application/use_cases/register_user.py
@@ -0,0 +1,14 @@
+from app.domain.models.user import User
+from app.infrastructure.repositories.user_repository import UserRepository
+
+
+class RegisterUser:
+    """Create and persist a user entity."""
+
+    def __init__(self, repository: UserRepository):
+        self.repository = repository
+
+    def execute(self, email: str, phone_number: str, external_auth_id: str | None = None) -> User:
+        user = User(email=email, phone_number=phone_number, external_auth_id=external_auth_id)
+        self.repository.add(user)
+        return user
diff --git a/app/domain/__init__.py b/app/domain/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/app/domain/models/plan.py b/app/domain/models/plan.py
new file mode 100644
index 0000000000000000000000000000000000000000..065a5097f48d05a7172475360829b513e28059a9
--- /dev/null
+++ b/app/domain/models/plan.py
@@ -0,0 +1,17 @@
+from dataclasses import dataclass
+
+
+@dataclass
+class PlanSpec:
+    """Represents an admin-defined hosting plan with performance presets."""
+
+    name: str
+    vcpu: int
+    memory_mb: int
+    disk_gb: int
+    location: str
+    proxmox_host_id: str | None = None
+    proxmox_node: str | None = None
+    template_vmid: int | None = None
+    disk_storage: str | None = None
+    description: str | None = None
diff --git a/app/domain/models/proxmox_host.py b/app/domain/models/proxmox_host.py
new file mode 100644
index 0000000000000000000000000000000000000000..aa80d3e8f81eb04e50cbdba1d1dd55420f2a1463
--- /dev/null
+++ b/app/domain/models/proxmox_host.py
@@ -0,0 +1,14 @@
+from dataclasses import dataclass
+
+
+@dataclass
+class ProxmoxHostConfig:
+    """Credentials and topology for a Proxmox API endpoint."""
+
+    id: str
+    api_url: str
+    username: str
+    password: str
+    realm: str = "pam"
+    node: str | None = None
+    location: str = "kr-central"
diff --git a/app/domain/models/server.py b/app/domain/models/server.py
new file mode 100644
index 0000000000000000000000000000000000000000..4a586b472165cd8f3d693ba92d56b6c60b5ba337
--- /dev/null
+++ b/app/domain/models/server.py
@@ -0,0 +1,30 @@
+from dataclasses import dataclass, field
+from datetime import datetime
+from enum import Enum
+from uuid import UUID, uuid4
+
+
+class ServerStatus(str, Enum):
+    PENDING = "pending"
+    PROVISIONING = "provisioning"
+    ACTIVE = "active"
+    FAILED = "failed"
+    ROLLED_BACK = "rolled_back"
+
+
+@dataclass
+class Server:
+    """Server entity tracked in the domain."""
+
+    owner_id: UUID
+    plan: str
+    location: str
+    proxmox_host_id: str | None = None
+    proxmox_node: str | None = None
+    vcpu: int | None = None
+    memory_mb: int | None = None
+    disk_gb: int | None = None
+    status: ServerStatus = ServerStatus.PENDING
+    id: UUID = field(default_factory=uuid4)
+    created_at: datetime = field(default_factory=datetime.utcnow)
+    external_id: str | None = None
diff --git a/app/domain/models/user.py b/app/domain/models/user.py
new file mode 100644
index 0000000000000000000000000000000000000000..5bc4b62608903bb1b8cc245043b4050031c1f892
--- /dev/null
+++ b/app/domain/models/user.py
@@ -0,0 +1,14 @@
+from dataclasses import dataclass, field
+from datetime import datetime
+from uuid import UUID, uuid4
+
+
+@dataclass
+class User:
+    """Core user entity representing an account inside the platform."""
+
+    email: str
+    phone_number: str
+    external_auth_id: str | None = None
+    id: UUID = field(default_factory=uuid4)
+    created_at: datetime = field(default_factory=datetime.utcnow)
diff --git a/app/domain/services/provisioning_policy.py b/app/domain/services/provisioning_policy.py
new file mode 100644
index 0000000000000000000000000000000000000000..0d04c5dab3097cbda043a84c33d5a646b47137ce
--- /dev/null
+++ b/app/domain/services/provisioning_policy.py
@@ -0,0 +1,35 @@
+from app.domain.models.plan import PlanSpec
+from app.domain.models.proxmox_host import ProxmoxHostConfig
+from app.infrastructure.repositories.plan_repository import PlanRepository
+from app.infrastructure.repositories.proxmox_host_repository import ProxmoxHostRepository
+
+
+class ProvisioningPolicy:
+    """Domain rules for validating whether a server can be provisioned."""
+
+    def __init__(self, plans: PlanRepository, proxmox_hosts: ProxmoxHostRepository):
+        self.plans = plans
+        self.proxmox_hosts = proxmox_hosts
+
+    def resolve_plan(self, plan_name: str) -> PlanSpec:
+        plan = self.plans.get(plan_name)
+        if not plan:
+            raise ValueError(f"Unsupported plan: {plan_name}")
+        return plan
+
+    def resolve_host(self, location: str, plan: PlanSpec) -> ProxmoxHostConfig:
+        if plan.location != location:
+            raise ValueError(
+                f"Plan '{plan.name}' is only available in {plan.location}, requested {location}"
+            )
+
+        if plan.proxmox_host_id:
+            host = self.proxmox_hosts.get(plan.proxmox_host_id)
+            if not host:
+                raise ValueError(f"No Proxmox host configured with id '{plan.proxmox_host_id}'")
+            return host
+
+        host = self.proxmox_hosts.first_for_location(location)
+        if not host:
+            raise ValueError(f"No Proxmox host available for location {location}")
+        return host
diff --git a/app/infrastructure/__init__.py b/app/infrastructure/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/app/infrastructure/clients/proxmox.py b/app/infrastructure/clients/proxmox.py
new file mode 100644
index 0000000000000000000000000000000000000000..aeff875e9c9a1f15e12ac5a524ec2226a5d10035
--- /dev/null
+++ b/app/infrastructure/clients/proxmox.py
@@ -0,0 +1,108 @@
+from typing import Tuple
+
+import httpx
+
+from app.domain.models.plan import PlanSpec
+from app.domain.models.proxmox_host import ProxmoxHostConfig
+from app.domain.models.server import Server
+
+
+class ProxmoxClient:
+    """Thin wrapper around Proxmox HTTP API (https://pve.proxmox.com/pve-docs/api-viewer/)."""
+
+    def __init__(self):
+        self.http = httpx.Client(timeout=10.0, verify=False)
+
+    def authenticate(self, host: ProxmoxHostConfig) -> Tuple[str, str | None]:
+        """Login with username/password and return (ticket, csrf)."""
+
+        base_url = host.api_url.rstrip("/")
+        login_payload = {
+            "username": f"{host.username}@{host.realm}" if host.realm else host.username,
+            "password": host.password,
+        }
+        response = self.http.post(f"{base_url}/api2/json/access/ticket", data=login_payload)
+        response.raise_for_status()
+        data = response.json()["data"]
+        return data["ticket"], data.get("CSRFPreventionToken")
+
+    def _headers(self, ticket: str, csrf: str | None) -> dict[str, str]:
+        headers = {"Cookie": f"PVEAuthCookie={ticket}"}
+        if csrf:
+            headers["CSRFPreventionToken"] = csrf
+        return headers
+
+    def provision_server(self, server: Server, plan: PlanSpec, host: ProxmoxHostConfig) -> str:
+        """Provision a server and return the Proxmox-assigned identifier."""
+
+        ticket, csrf = self.authenticate(host)
+        node = plan.proxmox_node or host.node
+        if not node:
+            raise ValueError("Proxmox node must be configured on the plan or host")
+
+        base_url = host.api_url.rstrip("/")
+        vm_name = f"vm-{server.id}"
+        vmid = self._generate_vmid(server)
+
+        if plan.template_vmid:
+            response = self.http.post(
+                f"{base_url}/api2/json/nodes/{node}/qemu/{plan.template_vmid}/clone",
+                data={
+                    "newid": vmid,
+                    "name": vm_name,
+                    "target": node,
+                    "full": 1,
+                    "storage": plan.disk_storage or "local-lvm",
+                },
+                headers=self._headers(ticket, csrf),
+            )
+            response.raise_for_status()
+        else:
+            payload = {
+                "vmid": vmid,
+                "name": vm_name,
+                "cores": plan.vcpu,
+                "memory": plan.memory_mb,
+                "sockets": 1,
+                "ostype": "l26",
+                "virtio0": f"{plan.disk_storage or 'local-lvm'}:{plan.disk_gb}G",
+            }
+
+            response = self.http.post(
+                f"{base_url}/api2/json/nodes/{node}/qemu",
+                data=payload,
+                headers=self._headers(ticket, csrf),
+            )
+            response.raise_for_status()
+
+        # ensure resources match plan for cloned templates
+        self.http.put(
+            f"{base_url}/api2/json/nodes/{node}/qemu/{vmid}/config",
+            data={
+                "cores": plan.vcpu,
+                "memory": plan.memory_mb,
+                "name": vm_name,
+                "virtio0": f"{plan.disk_storage or 'local-lvm'}:{plan.disk_gb}G",
+            },
+            headers=self._headers(ticket, csrf),
+        ).raise_for_status()
+
+        return str(vmid)
+
+    def destroy_server(self, external_id: str, host: ProxmoxHostConfig, node: str | None = None) -> None:
+        """Rollback helper to clean up failed provisioning attempts."""
+
+        ticket, csrf = self.authenticate(host)
+        target_node = node or host.node
+        if not target_node:
+            raise ValueError("Proxmox node required to delete VM")
+
+        response = self.http.delete(
+            f"{host.api_url.rstrip('/')}/api2/json/nodes/{target_node}/qemu/{external_id}",
+            headers=self._headers(ticket, csrf),
+        )
+        response.raise_for_status()
+
+    @staticmethod
+    def _generate_vmid(server: Server) -> int:
+        return abs(server.id.int % 2_000_000_000) or 1000
diff --git a/app/infrastructure/clients/solapi.py b/app/infrastructure/clients/solapi.py
new file mode 100644
index 0000000000000000000000000000000000000000..0558e27259511cc568021c7d90c2949d31fed2d5
--- /dev/null
+++ b/app/infrastructure/clients/solapi.py
@@ -0,0 +1,19 @@
+from app.infrastructure.config.settings import settings
+
+
+class SolapiClient:
+    """Minimal SOLAPI SMS sender abstraction."""
+
+    def __init__(self):
+        self.api_key = settings.solapi_api_key
+        self.api_secret = settings.solapi_api_secret
+        self.from_number = settings.solapi_from_number
+
+    def send_provisioning_sms(self, to: str, message: str) -> None:
+        """Send an SMS via SOLAPI.
+
+        The real implementation would use the official SDK: https://developers.solapi.dev
+        """
+
+        # Placeholder hook for the official client
+        return None
diff --git a/app/infrastructure/config/settings.py b/app/infrastructure/config/settings.py
new file mode 100644
index 0000000000000000000000000000000000000000..41018f11368860addb7bdb22c6b2dfa3a3474221
--- /dev/null
+++ b/app/infrastructure/config/settings.py
@@ -0,0 +1,29 @@
+from pydantic import BaseSettings, Field
+
+
+class Settings(BaseSettings):
+    """Runtime configuration for external services and application defaults."""
+
+    app_name: str = Field("VibeCoding Host Automation", env="APP_NAME")
+    environment: str = Field("local", env="APP_ENV")
+
+    # Proxmox settings
+    proxmox_host: str = Field("https://proxmox.local", env="PROXMOX_HOST")
+    proxmox_username: str = Field("root", env="PROXMOX_USERNAME")
+    proxmox_password: str = Field("", env="PROXMOX_PASSWORD")
+    proxmox_realm: str = Field("pam", env="PROXMOX_REALM")
+
+    # SOLAPI settings
+    solapi_api_key: str = Field("", env="SOLAPI_KEY")
+    solapi_api_secret: str = Field("", env="SOLAPI_SECRET")
+    solapi_from_number: str = Field("", env="SOLAPI_FROM")
+
+    # Persistence
+    database_path: str = Field("data/vibecoding.db", env="DATABASE_PATH")
+
+    class Config:
+        env_file = ".env"
+        env_file_encoding = "utf-8"
+
+
+settings = Settings()
diff --git a/app/infrastructure/repositories/plan_repository.py b/app/infrastructure/repositories/plan_repository.py
new file mode 100644
index 0000000000000000000000000000000000000000..c6c2e80d0d9abb3e9e521703a24e8f9d8f3ccb2d
--- /dev/null
+++ b/app/infrastructure/repositories/plan_repository.py
@@ -0,0 +1,64 @@
+from typing import Iterable, Optional
+
+from app.domain.models.plan import PlanSpec
+from app.infrastructure.storage.sqlite import SQLiteDataStore
+
+
+class PlanRepository:
+    """SQLite-backed store for admin-defined hosting plans."""
+
+    def __init__(self, db: SQLiteDataStore):
+        self.db = db
+
+    def add(self, plan: PlanSpec) -> None:
+        self.db.execute(
+            """
+            INSERT INTO plans (name, vcpu, memory_mb, disk_gb, location, proxmox_host_id, proxmox_node, description, template_vmid, disk_storage)
+            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+            ON CONFLICT(name) DO UPDATE SET
+                vcpu=excluded.vcpu,
+                memory_mb=excluded.memory_mb,
+                disk_gb=excluded.disk_gb,
+                location=excluded.location,
+                proxmox_host_id=excluded.proxmox_host_id,
+                proxmox_node=excluded.proxmox_node,
+                description=excluded.description,
+                template_vmid=excluded.template_vmid,
+                disk_storage=excluded.disk_storage
+            """,
+            (
+                plan.name,
+                plan.vcpu,
+                plan.memory_mb,
+                plan.disk_gb,
+                plan.location,
+                plan.proxmox_host_id,
+                plan.proxmox_node,
+                plan.description,
+                plan.template_vmid,
+                plan.disk_storage,
+            ),
+        )
+
+    def get(self, name: str) -> Optional[PlanSpec]:
+        row = self.db.fetch_one("SELECT * FROM plans WHERE name = ?", (name,))
+        return self._row_to_plan(row) if row else None
+
+    def list(self) -> Iterable[PlanSpec]:
+        rows = self.db.fetch_all("SELECT * FROM plans")
+        return [self._row_to_plan(row) for row in rows]
+
+    @staticmethod
+    def _row_to_plan(row) -> PlanSpec:
+        return PlanSpec(
+            name=row["name"],
+            vcpu=row["vcpu"],
+            memory_mb=row["memory_mb"],
+            disk_gb=row["disk_gb"],
+            location=row["location"],
+            proxmox_host_id=row["proxmox_host_id"],
+            proxmox_node=row["proxmox_node"],
+            description=row["description"],
+            template_vmid=row["template_vmid"],
+            disk_storage=row["disk_storage"],
+        )
diff --git a/app/infrastructure/repositories/proxmox_host_repository.py b/app/infrastructure/repositories/proxmox_host_repository.py
new file mode 100644
index 0000000000000000000000000000000000000000..7de314783688e319e21365d3834ac8ba1594bb21
--- /dev/null
+++ b/app/infrastructure/repositories/proxmox_host_repository.py
@@ -0,0 +1,59 @@
+from typing import Iterable, Optional
+
+from app.domain.models.proxmox_host import ProxmoxHostConfig
+from app.infrastructure.storage.sqlite import SQLiteDataStore
+
+
+class ProxmoxHostRepository:
+    """SQLite-backed metadata store for Proxmox hosts and nodes."""
+
+    def __init__(self, db: SQLiteDataStore):
+        self.db = db
+
+    def add(self, host: ProxmoxHostConfig) -> None:
+        self.db.execute(
+            """
+            INSERT INTO proxmox_hosts (id, api_url, username, password, realm, node, location)
+            VALUES (?, ?, ?, ?, ?, ?, ?)
+            ON CONFLICT(id) DO UPDATE SET
+                api_url=excluded.api_url,
+                username=excluded.username,
+                password=excluded.password,
+                realm=excluded.realm,
+                node=excluded.node,
+                location=excluded.location
+            """,
+            (
+                host.id,
+                host.api_url,
+                host.username,
+                host.password,
+                host.realm,
+                host.node,
+                host.location,
+            ),
+        )
+
+    def get(self, host_id: str) -> Optional[ProxmoxHostConfig]:
+        row = self.db.fetch_one("SELECT * FROM proxmox_hosts WHERE id = ?", (host_id,))
+        return self._row_to_host(row) if row else None
+
+    def list(self) -> Iterable[ProxmoxHostConfig]:
+        rows = self.db.fetch_all("SELECT * FROM proxmox_hosts")
+        return [self._row_to_host(row) for row in rows]
+
+    def first_for_location(self, location: str) -> Optional[ProxmoxHostConfig]:
+        row = self.db.fetch_one("SELECT * FROM proxmox_hosts WHERE location = ?", (location,))
+        return self._row_to_host(row) if row else None
+
+    @staticmethod
+    def _row_to_host(row) -> ProxmoxHostConfig:
+        return ProxmoxHostConfig(
+            id=row["id"],
+            api_url=row["api_url"],
+            username=row["username"],
+            password=row["password"],
+            realm=row["realm"],
+            node=row["node"],
+            location=row["location"],
+        )
diff --git a/app/infrastructure/repositories/server_repository.py b/app/infrastructure/repositories/server_repository.py
new file mode 100644
index 0000000000000000000000000000000000000000..616a2e6c3951ba2fd9cebd776582f58709ef78e9
--- /dev/null
+++ b/app/infrastructure/repositories/server_repository.py
@@ -0,0 +1,75 @@
+from collections.abc import Iterable
+from datetime import datetime
+from typing import Optional
+from uuid import UUID
+
+from app.domain.models.server import Server, ServerStatus
+from app.infrastructure.storage.sqlite import SQLiteDataStore
+
+
+class ServerRepository:
+    """SQLite persistence for server entities."""
+
+    def __init__(self, db: SQLiteDataStore):
+        self.db = db
+
+    def add(self, server: Server) -> None:
+        self.db.execute(
+            """
+            INSERT INTO servers (id, owner_id, plan, location, proxmox_host_id, proxmox_node, vcpu, memory_mb, disk_gb, status, created_at, external_id)
+            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+            ON CONFLICT(id) DO UPDATE SET
+                owner_id=excluded.owner_id,
+                plan=excluded.plan,
+                location=excluded.location,
+                proxmox_host_id=excluded.proxmox_host_id,
+                proxmox_node=excluded.proxmox_node,
+                vcpu=excluded.vcpu,
+                memory_mb=excluded.memory_mb,
+                disk_gb=excluded.disk_gb,
+                status=excluded.status,
+                external_id=excluded.external_id
+            """,
+            (
+                str(server.id),
+                str(server.owner_id),
+                server.plan,
+                server.location,
+                server.proxmox_host_id,
+                server.proxmox_node,
+                server.vcpu,
+                server.memory_mb,
+                server.disk_gb,
+                server.status.value,
+                server.created_at.isoformat(),
+                server.external_id,
+            ),
+        )
+
+    def update(self, server: Server) -> None:
+        self.add(server)
+
+    def get(self, server_id: UUID) -> Optional[Server]:
+        row = self.db.fetch_one("SELECT * FROM servers WHERE id = ?", (str(server_id),))
+        return self._row_to_server(row) if row else None
+
+    def list_for_user(self, user_id: UUID) -> Iterable[Server]:
+        rows = self.db.fetch_all("SELECT * FROM servers WHERE owner_id = ?", (str(user_id),))
+        return [self._row_to_server(row) for row in rows]
+
+    @staticmethod
+    def _row_to_server(row) -> Server:
+        return Server(
+            id=UUID(row["id"]),
+            owner_id=UUID(row["owner_id"]),
+            plan=row["plan"],
+            location=row["location"],
+            proxmox_host_id=row["proxmox_host_id"],
+            proxmox_node=row["proxmox_node"],
+            vcpu=row["vcpu"],
+            memory_mb=row["memory_mb"],
+            disk_gb=row["disk_gb"],
+            status=ServerStatus(row["status"]),
+            created_at=datetime.fromisoformat(row["created_at"]),
+            external_id=row["external_id"],
+        )
diff --git a/app/infrastructure/repositories/user_repository.py b/app/infrastructure/repositories/user_repository.py
new file mode 100644
index 0000000000000000000000000000000000000000..086313db219d99599eaeac3e9bacbbda79b94e75
--- /dev/null
+++ b/app/infrastructure/repositories/user_repository.py
@@ -0,0 +1,51 @@
+from collections.abc import Iterable
+from datetime import datetime
+from typing import Optional
+from uuid import UUID
+
+from app.domain.models.user import User
+from app.infrastructure.storage.sqlite import SQLiteDataStore
+
+
+class UserRepository:
+    """SQLite-backed repository for users."""
+
+    def __init__(self, db: SQLiteDataStore):
+        self.db = db
+
+    def add(self, user: User) -> None:
+        self.db.execute(
+            """
+            INSERT INTO users (id, email, phone_number, external_auth_id, created_at)
+            VALUES (?, ?, ?, ?, ?)
+            ON CONFLICT(id) DO UPDATE SET
+                email=excluded.email,
+                phone_number=excluded.phone_number,
+                external_auth_id=excluded.external_auth_id
+            """,
+            (
+                str(user.id),
+                user.email,
+                user.phone_number,
+                user.external_auth_id,
+                user.created_at.isoformat(),
+            ),
+        )
+
+    def get(self, user_id: UUID) -> Optional[User]:
+        row = self.db.fetch_one("SELECT * FROM users WHERE id = ?", (str(user_id),))
+        return self._row_to_user(row) if row else None
+
+    def list(self) -> Iterable[User]:
+        rows = self.db.fetch_all("SELECT * FROM users")
+        return [self._row_to_user(row) for row in rows]
+
+    @staticmethod
+    def _row_to_user(row) -> User:
+        return User(
+            id=UUID(row["id"]),
+            email=row["email"],
+            phone_number=row["phone_number"],
+            external_auth_id=row["external_auth_id"],
+            created_at=datetime.fromisoformat(row["created_at"]),
+        )
diff --git a/app/infrastructure/storage/__init__.py b/app/infrastructure/storage/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..4356d93964eabed5bbcec81df95a64f4135eb8de
--- /dev/null
+++ b/app/infrastructure/storage/__init__.py
@@ -0,0 +1,2 @@
+"""Storage layer implementations (SQLite, etc)."""
+
diff --git a/app/infrastructure/storage/sqlite.py b/app/infrastructure/storage/sqlite.py
new file mode 100644
index 0000000000000000000000000000000000000000..944128ae853d72da34772daadfc34d8657cb11a2
--- /dev/null
+++ b/app/infrastructure/storage/sqlite.py
@@ -0,0 +1,90 @@
+from __future__ import annotations
+
+import os
+import sqlite3
+from sqlite3 import Row
+from typing import Iterable, Optional
+
+
+class SQLiteDataStore:
+    """Lightweight SQLite helper for persisting domain entities."""
+
+    def __init__(self, path: str):
+        os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
+        self.conn = sqlite3.connect(path, check_same_thread=False)
+        self.conn.row_factory = sqlite3.Row
+        self._init_schema()
+
+    def _init_schema(self) -> None:
+        cur = self.conn.cursor()
+        cur.execute(
+            """
+            CREATE TABLE IF NOT EXISTS users (
+                id TEXT PRIMARY KEY,
+                email TEXT NOT NULL,
+                phone_number TEXT NOT NULL,
+                external_auth_id TEXT,
+                created_at TEXT NOT NULL
+            )
+            """
+        )
+        cur.execute(
+            """
+            CREATE TABLE IF NOT EXISTS plans (
+                name TEXT PRIMARY KEY,
+                vcpu INTEGER NOT NULL,
+                memory_mb INTEGER NOT NULL,
+                disk_gb INTEGER NOT NULL,
+                location TEXT NOT NULL,
+                proxmox_host_id TEXT,
+                proxmox_node TEXT,
+                description TEXT,
+                template_vmid INTEGER,
+                disk_storage TEXT
+            )
+            """
+        )
+        cur.execute(
+            """
+            CREATE TABLE IF NOT EXISTS proxmox_hosts (
+                id TEXT PRIMARY KEY,
+                api_url TEXT NOT NULL,
+                username TEXT NOT NULL,
+                password TEXT NOT NULL,
+                realm TEXT NOT NULL,
+                node TEXT,
+                location TEXT NOT NULL
+            )
+            """
+        )
+        cur.execute(
+            """
+            CREATE TABLE IF NOT EXISTS servers (
+                id TEXT PRIMARY KEY,
+                owner_id TEXT NOT NULL,
+                plan TEXT NOT NULL,
+                location TEXT NOT NULL,
+                proxmox_host_id TEXT,
+                proxmox_node TEXT,
+                vcpu INTEGER,
+                memory_mb INTEGER,
+                disk_gb INTEGER,
+                status TEXT NOT NULL,
+                created_at TEXT NOT NULL,
+                external_id TEXT
+            )
+            """
+        )
+        self.conn.commit()
+
+    def execute(self, query: str, params: Iterable | tuple = ()) -> None:
+        self.conn.execute(query, params)
+        self.conn.commit()
+
+    def fetch_one(self, query: str, params: Iterable | tuple = ()) -> Optional[Row]:
+        cur = self.conn.execute(query, params)
+        return cur.fetchone()
+
+    def fetch_all(self, query: str, params: Iterable | tuple = ()) -> list[Row]:
+        cur = self.conn.execute(query, params)
+        return cur.fetchall()
diff --git a/app/interfaces/__init__.py b/app/interfaces/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/app/interfaces/schemas.py b/app/interfaces/schemas.py
new file mode 100644
index 0000000000000000000000000000000000000000..87d734914258103e81f9c7ba5761202ef8f3a770
--- /dev/null
+++ b/app/interfaces/schemas.py
@@ -0,0 +1,132 @@
+from uuid import UUID
+
+from pydantic import BaseModel, EmailStr, Field
+
+from app.domain.models.plan import PlanSpec
+from app.domain.models.server import Server, ServerStatus
+from app.domain.models.proxmox_host import ProxmoxHostConfig
+from app.domain.models.user import User
+
+
+class UserCreate(BaseModel):
+    email: EmailStr
+    phone_number: str = Field(..., min_length=8)
+    external_auth_id: str | None = Field(
+        default=None, description="External auth provider user id to link with"
+    )
+
+
+class UserRead(BaseModel):
+    id: UUID
+    email: EmailStr
+    phone_number: str
+    external_auth_id: str | None
+
+    @classmethod
+    def from_entity(cls, user: User) -> "UserRead":
+        return cls(
+            id=user.id,
+            email=user.email,
+            phone_number=user.phone_number,
+            external_auth_id=user.external_auth_id,
+        )
+
+
+class ServerCreate(BaseModel):
+    user_id: UUID
+    plan: str
+    location: str
+
+
+class ServerRead(BaseModel):
+    id: UUID
+    owner_id: UUID
+    plan: str
+    location: str
+    proxmox_host_id: str | None
+    proxmox_node: str | None
+    vcpu: int | None
+    memory_mb: int | None
+    disk_gb: int | None
+    status: ServerStatus
+    external_id: str | None
+
+    @classmethod
+    def from_entity(cls, server: Server) -> "ServerRead":
+        return cls(
+            id=server.id,
+            owner_id=server.owner_id,
+            plan=server.plan,
+            location=server.location,
+            proxmox_host_id=server.proxmox_host_id,
+            proxmox_node=server.proxmox_node,
+            vcpu=server.vcpu,
+            memory_mb=server.memory_mb,
+            disk_gb=server.disk_gb,
+            status=server.status,
+            external_id=server.external_id,
+        )
+
+
+class PlanCreate(BaseModel):
+    name: str
+    vcpu: int = Field(..., gt=0)
+    memory_mb: int = Field(..., gt=256)
+    disk_gb: int = Field(..., gt=5)
+    location: str
+    proxmox_host_id: str | None = None
+    proxmox_node: str | None = None
+    template_vmid: int | None = Field(
+        default=None, description="Optional template VMID to clone when provisioning"
+    )
+    disk_storage: str | None = Field(
+        default=None, description="Preferred storage target when creating/cloning"
+    )
+    description: str | None = None
+
+
+class PlanRead(BaseModel):
+    name: str
+    vcpu: int
+    memory_mb: int
+    disk_gb: int
+    location: str
+    proxmox_host_id: str | None
+    proxmox_node: str | None
+    template_vmid: int | None
+    disk_storage: str | None
+    description: str | None
+
+    @classmethod
+    def from_entity(cls, plan: PlanSpec) -> "PlanRead":
+        return cls(**plan.__dict__)
+
+
+class ProxmoxHostCreate(BaseModel):
+    id: str = Field(..., description="Internal identifier for referencing the host")
+    api_url: str = Field(..., example="https://pve1.local")
+    username: str
+    password: str
+    realm: str = Field("pam", description="Authentication realm, e.g. pam or pve")
+    node: str | None = Field(None, description="Default node name to schedule on")
+    location: str = Field("kr-central", description="Geographic/location tag")
+
+
+class ProxmoxHostRead(BaseModel):
+    id: str
+    api_url: str
+    username: str
+    realm: str
+    node: str | None
+    location: str
+
+    @classmethod
+    def from_entity(cls, host: ProxmoxHostConfig) -> "ProxmoxHostRead":
+        return cls(
+            id=host.id,
+            api_url=host.api_url,
+            username=host.username,
+            realm=host.realm,
+            node=host.node,
+            location=host.location,
+        )
diff --git a/app/main.py b/app/main.py
new file mode 100644
index 0000000000000000000000000000000000000000..8e960558429eb95b8d5ca5e88142a34e14d661f6
--- /dev/null
+++ b/app/main.py
@@ -0,0 +1,15 @@
+from fastapi import FastAPI
+
+from app.api.routes import admin, servers, users
+from app.infrastructure.config.settings import settings
+
+app = FastAPI(title=settings.app_name, version="0.1.0")
+
+app.include_router(users.router)
+app.include_router(admin.router)
+app.include_router(servers.router)
+
+
+@app.get("/healthz")
+def healthcheck():
+    return {"status": "ok", "environment": settings.environment}
diff --git a/main.py b/main.py
index 3c85ea1a84d7c4859853f69e70848fb798a7f314..4535d673290820143e6c4e1305d642f896f201eb 100644
--- a/main.py
+++ b/main.py
@@ -1 +1,3 @@
-print("Hello, World")
\ No newline at end of file
+from app.main import app
+
+__all__ = ["app"]
diff --git a/requirements.txt b/requirements.txt
new file mode 100644
index 0000000000000000000000000000000000000000..2332943d71bc713e778c45f6ed3c74b197a237db
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,4 @@
+fastapi>=0.104.0
+uvicorn>=0.23.0
+pydantic>=1.10.0
+httpx>=0.27.0

EOF
)